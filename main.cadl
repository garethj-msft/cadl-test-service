// TODO List:
// addressUrl/MSAaddressURL
// some extension mechanism so we can have a fast lifecycle
// Bulk /deep write supported on individual
// Filter
// Property,Type and op documentation
// lifecycle (implementation | experimental | privatePreview | publicPreview | releaseCandidate* | public | privileged | deprecated )
// deprecation details.
// serviceContainer
//       bindingPaths


import "@cadl-lang/rest";
import "@cadl-lang/openapi3";
import "@cadl-lang/msgraph";

@serviceTitle("Pet Store Service")
@serviceVersion("2021-03-25")
@Cadl.Rest.produces("application/json", "image/png")
@Cadl.Rest.consumes("application/json")
namespace microsoft.graph.petStore {

    // Import type for reuse without modification
    @import("@workload-oneDrive") model identity {
    }

    // Import type for reuse with mapping to internal names
    @import model identitySet {
        user: identity @workloadName("internalUser");
        device: identity;
        application: identity;
    }

    // Add properties to existing types
    @partial model microsoft.graph.user {
       @relation pets: pet[];
    }

    // Reference external type for extending
    @external model microsoft.graph.group {
    }

    model kennelClub : microsoft.graph.group {
    }

    model category {
      @id id: string @serverGenerated;
      displayName: string;
      petCount: int32 @serverGenerated;
    }

    model tag {
      displayName: string;
    }

    enum petStatus {
        @value(0) available, // Can we make this name @value()?
        @value(1) pending,
        @value(2) sold,
        @value(3) unknownFutureValue,
    }

    model outfit {
        @id id: string @serverGenerated;
        displayName: string @required;
        cutenessLevel: int32;
    }

    model pet { 
        @id id: string @serverGenerated;
        displayName: string @required; 
        photoUrls: string[];
        tags: tag[];
        breed: string @immutable;  // Can only be set on create
        status: petStatus;
        password: string @writeOnly;  
        owner: identitySet;
        @relation outfits: outfit[];
        @refRelation category: category;
    }

    @service
    model petService {
        pets: pet[];
        bestPet: pet;
        categories: category[];
    }

    using Cadl.Http;
    using Cadl.MsGraph;

    @route("/pets")
    namespace pets
    {
        op create(body: pet): TCreatedResponse<pet>;
        op list(testParam: int32): OkResponse<PagedList<pet>> @skip @top @count @expand("categories", "outfits");
        op patch(changes: pet[]): NoContentResponse;
        @post op makeAllThePetsPoster(): OKResponse<stream>;
    }

    @route("/pets/{id}")
    namespace petsById
    {
        op get(id: string): OkResponse<pet> | NotFoundResponse;
        op delete(id: string): NoContentResponse | NotFoundResponse;
        op patch(id: string, change: pet): NoContentResponse | NotFoundResponse;
    }
    
    @route("/pets/{id}/sendCutePostcard")
    {
        @post op sendCutePostcard(id: string, greeting: string): NoContentResponse | NotFoundResponse;;
    }

    @route("/pets/{id}/outfits")
    namespace petsByIdOutfits
    {
        op post() : TCreatedResponse<outfit>;
        op get(id: string): OkResponse<List<outfit> @orderBy("displayName");
    }

    @route("/pets/{petId}/outfits/{outfitId}")
    namespace petsByIdOutfitsById
    {
        op get(petId: string, outfitId: string): OkResponse<outfit> | NotFoundResponse;
        op delete(petId: string, outfitId: string): NoContentResponse | NotFoundResponse;
        op patch(petId: string, outfitId: string, changes: outfit): NoContentResponse | NotFoundResponse;
    }

    @route("/pets/{id}/category")
    namespace petsByIdCategory
    {
        op get(id: string): OkResponse<category> | NotFoundResponse;
        op put(id: string, category: Ref<category>): NoContentResponse | NotFoundResponse;
    }

    @route("/pets/{id}/category/$ref")
    namespace petsByIdCategoryRef
    {
        op get(id: string): OkResponse<Ref<category>> | NotFoundResponse;
        op delete(id: string): NoContentResponse | NotFoundResponse;
    }
    
    @route("/categories")
    namespace categories {
        op post(body: category): TCreatedResponse<category>;
        op get(): OkResponse<List<category>>;
    }

    @route("/categories/{id}")
    namespace categoriesById {
        op get(id: string): OkResponse<category> | NotFoundResponse;
        op delete(id: string): NoContentResponse | NotFoundResponse;
        op update(id: string, changes: category): NoContentResponse | NotFoundResponse;
    }
}



Core principal:   
Where API authors have a decision to make, we don't abstract it - make 'em think when they need to think.

1. parameter without @path (or any specifier) is in the path.
2. $skipToken is implied by PagedList<T>
3. HTTP methods are implied by the names: create, list, get, delete, update
4. (Check flags like $skip and $top can be at the end)
5. @select for all values is implied.
6. Models with an property annotated with @id are addressable (map to csdl entities, otherwise complex types).
7. Can we somehow combine namespace and @route - redundant at present - can we add new keywords?
8. @required and @serverGenerated create non-nullable properties. Otherwise the properties are optional and non-nullable.
